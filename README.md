# 2048
2048 is the second game I built using C++ and SFML. I built this game shortly after completing the Clappy Bird game. A large part of what I wanted to achieve with this second game was to work on my game structure a bit more, which I completed to some extent but still lack in some regards. I completed this game after finishing the C++ Game Programming 2 course on LinkedIn Learning, which expanded upon the teachings of the previous instalment.

I decided to build a clone of 2048 because I didn&#39;t want to expand too deep into new techniques and I imagined that this would be quite simple (I certainly underestimated this game in that regard!). I also wanted an opportunity to create my own simple assets for a game. The main thing I learnt when building this game is the importance of proper planning throughout the entire development cycle. I will discuss the issues I faced due to not planning below.

As with the Clappy Bird project, here is the code I have used from other sources:

1. The TextureHolder.cpp and TextureHolder.h files define a singleton object which serves as a cache for textures in the game. Instead of needing to pull in textures from their files every single time they are used, the TextureHolder object ensures that textures are only ever imported once – if a texture is requested after being imported, it will simply be loaded from the cache. This code was used in the C++ Game Programming 1 course, and all credit for this approach is given to John Horton, the instructor for that course.

The assets, as mentioned above, were created by me using Macromedia Fireworks. All other code in the game was written by me also.

Some of the key challenges of this game were:

1. Constructing a game board with an array of tile objects. The GameBoard class is where most of the logic takes place (probably something I&#39;ll refactor to another class in the future), and it primarily controls a 2D array of Tile objects. The Tile objects have sprites assigned to them and are invisible when they have no value. The background image gives the illusion that they are visible, however. I used an unholy amount of nested for loops to iterate through this array – I am not happy with this and will look to improve it for future games.
2. The movement system was far more complex than I ever imagined it. When you think of 2048, you think of something quite simple – all tiles move as far over to the side as possible, and any tiles that match are combined into a tile of double the value. However, both the implementation of this and the edge cases that can arise with general movement really took me by surprise with how complex they were. First, you must move all objects as far in the direction chosen as possible. Next, you must see if any items can be combined (checking in the correct order to ensure the right tiles are combined in ambiguous cases), before combining them. Finally, you must again move all objects as far in the same direction as possible to account for gaps that open up by combining tiles. The speed of the animation of the tile moving to its correct position needs to be modified depending on the distance the tile must travel, such that all tiles arrive in their new locations at the same time. These are just some examples of all the nitty details that I overlooked when jumping head-first into this game – I will discuss the shortcomings of this shortly
3. Animating the movement was also quite complex, although I think a large part of this was due to my poor structuring of the movement in general within the code base. When a tile moves, it must be animated as moving to the correct location – after which it must be set back to its original position. See, the tiles themselves never actually change place – only the values within. If a tile has been combined and now holds the new value, it must pulse outwards slightly to indicate that this combination has happened (see online 2048 implementations for how this would work). This was done by simply updating their scale each frame up to a certain point where the max size was reached, before updating the scale downwards.

Overall, I&#39;m not too happy with the outcome of this project as a game, but I am grateful for the lessons it has taught me. I think the code I use to move pieces is horrendously inefficient, and I could have come up with a far superior solution had I invested time into the planning phase of this. Nevertheless, this is a valuable lesson and it&#39;s a mistake I won&#39;t make again. Additionally, I learnt that I can still progress further with my structuring – I started well but ended up with the GameBoard class containing almost all of the actual game. In the future I will separate the UI elements and game logic in a more flexible way.


See here: https://youtu.be/a-ranyWmiew for a demonstration of the game
